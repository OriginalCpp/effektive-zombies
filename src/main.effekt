module main

import mutable/map
import src/shapes/hitbox
import src/shapes/manipulated
import src/shapes/simple
import src/ffi
import src/vec2d

val KEY_DOWN = "keydown"
val KEY_UP = "keyup"
val MOUSE_MOVE = "mousemove"
val MOUSE_DOWN = "mousedown"

type GameObject {
  Shot(drawable: ManipulatedDrawable, movementVector: Vec2d)
  Zombie(drawable: ManipulatedDrawable, movementVector: Vec2d)
}

def getCenter(object: GameObject): Vec2d = object match {
  case Shot(hitbox, _) => hitbox.getCenter()
  case Zombie(hitbox, _) => hitbox.getCenter()
}

def getHitbox(object: GameObject): ManipulatedDrawable = object match {
  case Shot(hitbox, _) => hitbox
  case Zombie(hitbox, _) => hitbox
}

record Player(drawable: SimpleDrawable, gun: SimpleDrawable, speed: Double)

record GameState(player: Player, objects: List[GameObject])

def addObject(game: GameState, gameObject: GameObject): GameState = 
  GameState(game.player, Cons(gameObject, game.objects))

type Side {
  Top()
  Right()
  Bottom()
  Left()
}

val SIDES = [Top(), Right(), Bottom(), Left()]

interface Canvas {
  def draw(drawable: ManipulatedDrawable): Unit
  def clear(): Unit
}

effect random(): Double

/// Can return None if the given lists are not of the same length
/// or if the probabilities do not add up to 1
def choose[T](chooseFrom: List[T], probabilities: List[Double]): Option[T] / random = {
  val thresholds = probabilities.foldRight([]) { (prob, ts) =>
    val lastThreshold = ts.headOption().getOrElse{1.0}
    Cons((lastThreshold - prob), ts)
  }
  val random = do random()
  def p(t: Double): Bool = random > t
  val chosenIndex = thresholds.reverse.findIndex(p)
  
  val chosen = default[OutOfBounds, Option[T]] { None() } 
    { Some(chooseFrom.reverse.get(chosenIndex)) }
  chosen
}

def contains[T](list: List[T], elem: T) { equals: (T, T) => Bool }: Bool = list match {
  case Cons(x, rest) => x.equals(elem) || rest.contains(elem) {equals}
  case Nil() => false
}

def findIndex[T](list: List[T], predicate: T => Bool at {}): Int = {
  def go(list: List[T], i: Int): Int = list match {
    case Cons(x, rest) => if (predicate(x)) i else go(rest, i + 1)
    case Nil() => -1
  }
  go(list, 0)
}

interface Input {
  def isPressed(key: String): Bool
  def mousePos(): Vec2d
}

interface Screen {
  def width(): Double
  def height(): Double
}

interface Timer {
  def left(): Int
  def reset(): Unit
  def change(by: Int): Unit
}

def spawnZombie(game: GameState): GameObject / { Screen, random } = {
  val w = do width()
  val h = do height()
  val totalScreenEdge = 2.0 * w + 2.0 * h
  val sideProbs = [w, h, w, h].map {side => side / totalScreenEdge}
  val spawnSide = SIDES.choose(sideProbs).getOrElse{Right()}
  val r = do random()
  val zombiePos = spawnSide match {
    case Right() => Vec2d(w, r * h)
    case Bottom() => Vec2d(r * w, h)
    case Left() => Vec2d(0.0, r * h)
    case Top() => Vec2d(r * w, 0.0)
  }
  val player = game.player
  val zombieSize = h / 15.0
  val zombie = Zombie(Simple(Circle(zombiePos, zombieSize, Black())), Vec2d(0.3, 0.0))
  zombie
}

def move(gameObject: GameObject, dt: Int): GameObject = gameObject match {
  case Shot(hitbox, movementVector) => 
    Shot(hitbox.move(movementVector * dt), movementVector)
  case Zombie(hitbox, movementVector) =>
    Zombie(hitbox.move(movementVector * dt), movementVector)
}

def wasdDirection(): Vec2d / Input = {
  val wPressed = do isPressed("w") || do isPressed("W")
  val aPressed = do isPressed("a") || do isPressed("A")
  val sPressed = do isPressed("s") || do isPressed("S")
  val dPressed = do isPressed("d") || do isPressed("D")
  val xDirection = aPressed.toDouble.neg + dPressed.toDouble
  val yDirection = wPressed.toDouble.neg + sPressed.toDouble
  Vec2d(xDirection, yDirection).normalize()
}

def move(player: Player, dt: Int): Player / Input = {
  val movement = 
    player.speed * dt.toDouble * wasdDirection()
  Player(
    player.drawable.move(movement), 
    player.gun.move(movement), 
    player.speed
  )
}

def shooting(objects: List[GameObject]): List[GameObject] = {
  val (shots, zombies) = objects.partition {
    case Shot(_, _) => true
    case Zombie(_, _) => false
  }

  val (shotsThatHit, remainingShots) = shots.partition {
    case Shot(sHitbox, _) =>
      zombies.any {
        case Zombie(zHitbox, _) => sHitbox.collides(zHitbox)
        case _ => false
      }
    case _ => false
  }

  val (dead, alive) = zombies.partition {
    case Zombie(zHitbox, _) =>
      shotsThatHit.any {
        case Shot(sHitbox, _) => zHitbox.collides(sHitbox)
        case _ => false
      }
    case _              => false
  }

  alive.append(remainingShots)
}

def update(game: GameState, dt: Int): GameState / { Input, random, Screen, Timer } = {
  val player = game.player
  val movedPlayer = player.move(dt)
  val objects = game.objects

  val timeLeftToSpawn = do left() - dt
  val shouldSpawn = timeLeftToSpawn < 0
  val spawnedZombie = if (shouldSpawn) {
    do reset()
    do change(timeLeftToSpawn)
    [spawnZombie(game)] 
  } else {
    do change(dt.neg)
    []
  }

  val remainingObjects = shooting(spawnedZombie.append(game.objects))

  val movedObjects = remainingObjects.map {
    case Zombie(h, m) =>
      val zombieCenter = h.getCenter()
      val zombiePlayerVec = player.drawable.getCenter() - zombieCenter
      val missingAngle = angleClockwise(zombiePlayerVec) - angleClockwise(m)
      val newHitbox = Rotate(h, missingAngle, None()).collapseRotations()
      Zombie(newHitbox, m.rotate(missingAngle)).move(dt)
    case o => o.move(dt)
  }
  GameState(movedPlayer, movedObjects)
}

def render(game: GameState): Unit / { Canvas, Input } = {
  val gunAngle = 
    angleClockwise(do mousePos() - game.player.drawable.getCenter())
  do clear()
  do draw(Rotate(
    Compose(Simple(game.player.drawable),
    Simple(game.player.gun)), 
    gunAngle, None()
  ))
  game.objects.foreach { o => do draw(o.getHitbox()) }
}

def main(): Unit = {
  val CANVAS_WIDTH = clientWidth()
  val CANVAS_HEIGHT = clientHeight()
  val CANVAS_CENTER = Vec2d(CANVAS_WIDTH / 2.0, CANVAS_HEIGHT / 2.0)
  val canvas = createCanvas(CANVAS_WIDTH, CANVAS_HEIGHT)

  val PLAYER_SIZE = CANVAS_HEIGHT / 15.0
  val PLAYER_SPEED = 0.4
  val PLAYER_START_POS = CANVAS_CENTER
  val PLAYER_HITBOX = Circle(PLAYER_START_POS, PLAYER_SIZE, Green())
  val GUN_WIDTH  = PLAYER_SIZE / 1.2
  val GUN_HEIGTH = GUN_WIDTH / 3.0
  val GUN_START_POS = PLAYER_START_POS + Vec2d(PLAYER_SIZE - 1.0, -0.5 * GUN_HEIGTH)
  val GUN = Rect(GUN_START_POS, GUN_WIDTH, GUN_HEIGTH, Black())
  val START_PLAYER = Player(PLAYER_HITBOX, GUN, PLAYER_SPEED)

  val game = ref[GameState](GameState(START_PLAYER, []))

  val keysPressed = emptyMap[String, Bool]()
  val mousePos = ref[Vec2d](NULL_VECTOR)
  val lastFrameTimeStamp = ref[Int](getTime())

  val ZOMBIE_SPAWN_INTERVAL = 1000
  val zombieTimerMs = ref[Int](ZOMBIE_SPAWN_INTERVAL)

  def timeSinceLastFrame(): Int = {
    val now = getTime()
    val timeElapsed = now - lastFrameTimeStamp.get()
    lastFrameTimeStamp.set(now)
    timeElapsed
  }

  def idleCallback(deadline: IdleDeadline): Unit = {
    try {
      val updatedGame = game.get.update(timeSinceLastFrame()) 
      render(updatedGame)
      game.set(updatedGame)
    } with Canvas {
      def draw(drawable) = {
        def drawSimple(d: SimpleDrawable): Unit = d match {
          case Rect(upperLeft, width, height, color) =>
            canvas.drawRect(
              upperLeft.x, upperLeft.y, 
              width, height, show(color)
            )
          case Circle(center, radius, color) =>
            canvas.drawCircle(center.x, center.y, radius, show(color))
        }

        def unwrapDraw(d: ManipulatedDrawable): Unit = d match {
          case Simple(inner) => drawSimple(inner)
          case Rotate(inner, rotation, relativeTo) =>
            val oldMatrix = canvas.getTransform()
            val realRelative = relativeTo.getOrElse { inner.getCenter() }
            canvas.setupRotation(rotation, realRelative.x, realRelative.y)
            unwrapDraw(inner)
            canvas.setTransform(oldMatrix)
          case Compose(first, second) =>
            unwrapDraw(first); unwrapDraw(second)
        }
        unwrapDraw(drawable)
        resume(())
      }
      def clear = { canvas.clear(); resume(()) }
    } with Input {
      def isPressed(key) = resume(keysPressed.get(key).getOrElse { false })
      def mousePos() = resume(mousePos.get)
    } with random {
      resume(random())
    } with Screen {
      def width = resume(CANVAS_WIDTH)
      def height = resume(CANVAS_HEIGHT)
    } with Timer {
      def left() = resume(zombieTimerMs.get)
      def reset() = {
        zombieTimerMs.set(ZOMBIE_SPAWN_INTERVAL)
        resume(())
      }
      def change(by) = {
        zombieTimerMs.set(zombieTimerMs.get + by)
        resume(())
      }
    }
    
    requestIdleCallback(idleCallback)
  }

  def pressedHandler(event: Event): Unit = 
    keysPressed.update(event.getKey(), true)
  def releasedHandler(event: Event): Unit = 
    keysPressed.update(event.getKey(), false)

  def mouseMoveHandler(event: Event): Unit = {
    val x = event.getClientX()
    val y = event.getClientY()
    mousePos.set(Vec2d(x, y))
  }
  def mouseDownHandler(event: Event): Unit = {
    val leftButtonPressed = event.getButton() == 0
    if (leftButtonPressed) {
      val player = game.get.player
      val playerCenter = player.drawable.getCenter()
      val gunAngle = angleClockwise(mousePos.get - playerCenter)
      val shotDrawable = player.gun.changeColor(Black())
      val shot = Shot(
        Rotate(Simple(shotDrawable), gunAngle, Some(playerCenter)),
        Vec2d(1.0, 0.0).rotate(gunAngle)
      )
      game.set(game.get.addObject(shot))
    }
  }

  addEventListener(KEY_DOWN, pressedHandler)
  addEventListener(KEY_UP, releasedHandler)
  addEventListener(MOUSE_MOVE, mouseMoveHandler)
  addEventListener(MOUSE_DOWN, mouseDownHandler)

  requestIdleCallback(idleCallback)
}