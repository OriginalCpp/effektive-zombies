module game

import src/constants
import src/ffi
import src/text
import src/utils
import src/vec2d
import src/shapes/manipulated
import src/shapes/simple

interface Canvas {
  def draw(drawable: ManipulatedDrawable): Unit
  def write(text: Text): Unit
  def clear(): Unit
}

interface Input {
  def isPressed(key: String): Bool
  def mousePos(): Vec2d
}

interface Screen {
  def width(): Double
  def height(): Double
}

def visible(d: ManipulatedDrawable): Bool / Screen = 
  collides(d, Simple(Rect(NULL_VECTOR, do width(), do height(), Black())))

record Timer(left: Int)

effect elapsed[R](): (Timer, R)

def timer[R](t: Timer, elapsed: Int): (Timer, Option[R]) / elapsed[R] = {
  val remaining = t.left - elapsed
  val hasElapsed = remaining <= 0
  if (hasElapsed) {
    val (newTimer, result) = do elapsed[R]()
    (newTimer, Some(result))
  }
  else (Timer(remaining), None())
}

type GameObject {
  Bullet(drawable: ManipulatedDrawable, movementVector: Vec2d)
  Zombie(drawable: ManipulatedDrawable, movementVector: Vec2d)
}

def getCenter(object: GameObject): Vec2d = object match {
  case Bullet(hitbox, _) => hitbox.getCenter()
  case Zombie(hitbox, _) => hitbox.getCenter()
}

def getHitbox(object: GameObject): ManipulatedDrawable = object match {
  case Bullet(hitbox, _) => hitbox
  case Zombie(hitbox, _) => hitbox
}

record Player(drawable: SimpleDrawable, gun: SimpleDrawable, health: Int, speed: Double)

def isAlive(player: Player): Bool = player.health > 0

def changeHealth(player: Player, by: Int): Player = 
  Player(player.drawable, player.gun, player.health + by, player.speed)

def keepInsideScreen(player: Player): Player / Screen = {
  val screenW = do width()
  val screenH = do height()
  val playerCenter = player.drawable.getCenter()
  val centerInside = Vec2d(
    playerCenter.x.clamp(0.0, screenW),
    playerCenter.y.clamp(0.0, screenH)
  )
  val adjustment = centerInside - playerCenter
  Player(
    player.drawable.move(adjustment), 
    player.gun.move(adjustment), 
    player.health,
    player.speed
  )
}

record GameTimer(zombieTimer: Timer, waveTimer: Timer)

effect getWave(): Int

record GameState(player: Player, objects: List[GameObject], timers: GameTimer)

def addObject(game: GameState, gameObject: GameObject): GameState = 
  GameState(game.player, Cons(gameObject, game.objects), game.timers)

type Side {
  Top()
  Right()
  Bottom()
  Left()
}

val SIDES = [Top(), Right(), Bottom(), Left()]

def spawnZombie(game: GameState): GameObject / { Screen, random } = {
  val w = do width()
  val h = do height()
  val totalScreenEdge = 2.0 * w + 2.0 * h
  val sideProbs = [w, h, w, h].map {side => side / totalScreenEdge}
  val spawnSide = SIDES.choose(sideProbs).getOrElse{Right()}
  val r = do random()
  val zombiePos = spawnSide match {
    case Right() => Vec2d(w, r * h)
    case Bottom() => Vec2d(r * w, h)
    case Left() => Vec2d(0.0, r * h)
    case Top() => Vec2d(r * w, 0.0)
  }
  val player = game.player
  val zombieSize = h / 15.0
  val zombie = Zombie(Simple(Circle(zombiePos, zombieSize, Black())), Vec2d(0.3, 0.0))
  zombie
}

def move(gameObject: GameObject, dt: Int): GameObject = gameObject match {
  case Bullet(hitbox, movementVector) => 
    Bullet(hitbox.move(movementVector * dt), movementVector)
  case Zombie(hitbox, movementVector) =>
    Zombie(hitbox.move(movementVector * dt), movementVector)
}

def wasdDirection(): Vec2d / Input = {
  val wPressed = do isPressed("w") || do isPressed("W")
  val aPressed = do isPressed("a") || do isPressed("A")
  val sPressed = do isPressed("s") || do isPressed("S")
  val dPressed = do isPressed("d") || do isPressed("D")
  val xDirection = aPressed.toDouble.neg + dPressed.toDouble
  val yDirection = wPressed.toDouble.neg + sPressed.toDouble
  Vec2d(xDirection, yDirection).normalize()
}

def move(player: Player, dt: Int): Player / Input = {
  val movement = 
    player.speed * dt.toDouble * wasdDirection()
  Player(
    player.drawable.move(movement), 
    player.gun.move(movement),
    player.health,
    player.speed
  )
}

def shooting(objects: List[GameObject]): List[GameObject] = {
  val (bullets, zombies) = objects.partition {
    case Bullet(_, _) => true
    case Zombie(_, _) => false
  }

  val (bulletsThatHit, remainingBullets) = bullets.partition {
    case Bullet(sHitbox, _) =>
      zombies.any {
        case Zombie(zHitbox, _) => sHitbox.collides(zHitbox)
        case _ => false
      }
    case _ => false
  }

  val (dead, alive) = zombies.partition {
    case Zombie(zHitbox, _) =>
      bulletsThatHit.any {
        case Bullet(sHitbox, _) => zHitbox.collides(sHitbox)
        case _ => false
      }
    case _              => false
  }

  alive.append(remainingBullets)
}

def update(game: GameState, dt: Int): GameState / { getWave, Input, random, Screen } = {
  val player = game.player
  val movedPlayer = player.move(dt)
  val objects = game.objects

  val (updatedZombieTimer, spawnedZombie) = 
    try { game.timers.zombieTimer.timer[GameObject](dt) }
    with elapsed[GameObject] { 
      resume((Timer(ZOMBIE_SPAWN_INTERVAL / do getWave()), spawnZombie(game)))
    }

  val (inRange, outOfRange) = objects.partition {
    case Bullet(hitbox, _) => hitbox.visible()
    case _ => true
  } 

  val remainingAfterShooting = shooting(
    spawnedZombie.toList.append(inRange)
  )

  val (damagingZombies, remainingObjects) = remainingAfterShooting.partition {
    case Zombie(hitbox, _) => hitbox.collides(Simple(player.drawable))
    case _ => false
  }

  val playerHealthLoss = damagingZombies.size

  val movedObjects = remainingObjects.map {
    case Zombie(h, m) =>
      val zombieCenter = h.getCenter()
      val zombiePlayerVec = player.drawable.getCenter() - zombieCenter
      val missingAngle = angleClockwise(zombiePlayerVec) - angleClockwise(m)
      val newHitbox = Rotate(h, missingAngle, None()).collapseRotations()
      Zombie(newHitbox, m.rotate(missingAngle)).move(dt)
    case o => o.move(dt)
  }

  val updatedPlayer = movedPlayer.changeHealth(playerHealthLoss.neg)
                      .keepInsideScreen()

  val updatedTimers = GameTimer(updatedZombieTimer, game.timers.waveTimer)
  GameState(updatedPlayer, movedObjects, updatedTimers)
}

def render(game: GameState): Unit / { Canvas, Input } = {
  val gunAngle = 
    angleClockwise(do mousePos() - game.player.drawable.getCenter())
  do clear()
  do draw(Rotate(
    Compose(Simple(game.player.drawable),
    Simple(game.player.gun)), 
    gunAngle, None()
  ))
  game.objects.foreach { o => do draw(o.getHitbox()) }
}

def renderDeathScreen(): Unit / { Canvas, Screen } = {
  val w = do width()
  val h = do height()
  val center = Vec2d(w / 2.0, h / 2.0)

  val background = Simple(Rect(NULL_VECTOR, w, h, Black()))

  val YOU_DIED = Text(
    "You Died",
    center - fromInt(0, 100),
    48,
    Serif(),
    Center(),
    Bottom(),
    Red()
  )

  do draw(background)
  do write(YOU_DIED)
}