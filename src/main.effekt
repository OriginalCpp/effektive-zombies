module main

import mutable/map
import src/shapes/hitbox
import src/shapes/manipulated
import src/shapes/simple
import src/constants
import src/ffi
import src/game
import src/text
import src/utils
import src/vec2d

def main(): Unit = {
  val CANVAS_WIDTH = clientWidth()
  val CANVAS_HEIGHT = clientHeight()
  val CANVAS_CENTER = Vec2d(CANVAS_WIDTH / 2.0, CANVAS_HEIGHT / 2.0)
  val canvas = createCanvas(CANVAS_WIDTH, CANVAS_HEIGHT)

  val PLAYER_SIZE = CANVAS_HEIGHT / 15.0
  val PLAYER_SPEED = 0.4
  val PLAYER_HEALTH = 2
  val PLAYER_START_POS = CANVAS_CENTER
  val PLAYER_HITBOX = Circle(PLAYER_START_POS, PLAYER_SIZE, Green())
  val GUN_WIDTH  = PLAYER_SIZE / 1.2
  val GUN_HEIGTH = GUN_WIDTH / 3.0
  val GUN_START_POS = PLAYER_START_POS + Vec2d(PLAYER_SIZE - 1.0, -0.5 * GUN_HEIGTH)
  val GUN = Rect(GUN_START_POS, GUN_WIDTH, GUN_HEIGTH, Black())
  val START_PLAYER = Player(PLAYER_HITBOX, GUN, PLAYER_HEALTH, PLAYER_SPEED)

  val START_TIMERS = GameTimer(
    Timer(ZOMBIE_SPAWN_INTERVAL),
    Timer(START_WAVE_TIMER)
  )

  val START_SCORE = Score(0, 0, 0)

  val START_GAME = GameState(START_PLAYER, [], START_TIMERS, START_WAVE, START_SCORE)
  val game = ref[GameState](START_GAME)

  val keysPressed = emptyMap[String, Bool]()
  val mousePos = ref[Vec2d](NULL_VECTOR)
  val lastFrameTimeStamp = ref[Int](getTime())

  val RETRY_BUTTON_WIDTH = CANVAS_WIDTH / 4.0
  val RETRY_BUTTON_HEIGHT = CANVAS_HEIGHT / 6.0
  val RETRY_BUTTON_CENTER = CANVAS_CENTER + fromInt(0, 50)
  val RETRY_BUTTON = Rect(
    NULL_VECTOR, RETRY_BUTTON_WIDTH,
    RETRY_BUTTON_HEIGHT, Green()
  ).centerAt(RETRY_BUTTON_CENTER)
  val RETRY_TEXT = Text(
    "Retry", RETRY_BUTTON_CENTER, 64, Serif(), Center(), Middle(), White()
  )

  def timeSinceLastFrame(): Int = {
    val now = getTime()
    val timeElapsed = now - lastFrameTimeStamp.get()
    lastFrameTimeStamp.set(now)
    timeElapsed
  }

  def idleCallback(deadline: IdleDeadline): Unit = {
    try {
      val dt = timeSinceLastFrame()
      if (game.get.player.isAlive) {
        val updatedGame = game.get.update(dt) 
        render(updatedGame)
        game.set(updatedGame)
      } else {
        println(show(game.get.score))
        renderDeathScreen()
        do draw(Simple(RETRY_BUTTON))
        do write(RETRY_TEXT)
      }
    } with Canvas {
      def draw(drawable) = {
        def drawSimple(d: SimpleDrawable): Unit = d match {
          case Rect(upperLeft, width, height, color) =>
            canvas.drawRect(
              upperLeft.x, upperLeft.y, 
              width, height, show(color)
            )
          case Circle(center, radius, color) =>
            canvas.drawCircle(center.x, center.y, radius, show(color))
        }

        def unwrapDraw(d: ManipulatedDrawable): Unit = d match {
          case Simple(inner) => drawSimple(inner)
          case Rotate(inner, rotation, relativeTo) =>
            val oldMatrix = canvas.getTransform()
            val realRelative = relativeTo.getOrElse { inner.getCenter() }
            canvas.setupRotation(rotation, realRelative.x, realRelative.y)
            unwrapDraw(inner)
            canvas.setTransform(oldMatrix)
          case Compose(first, second) =>
            unwrapDraw(first); unwrapDraw(second)
        }
        unwrapDraw(drawable)
        resume(())
      }
      def write(text) = {
        canvas.drawText(
          text.text, text.position.x, text.position.y,
          show(text.fontSizePX) ++ "px " ++ show(text.fontType), 
          show(text.alignment), show(text.baseline), show(text.color)
        )
        resume(())
      }
      def clear = { canvas.clear(); resume(()) }
    } with Input {
      def isPressed(key) = resume(keysPressed.get(key).getOrElse { false })
      def mousePos() = resume(mousePos.get)
    } with random {
      resume(random())
    } with Screen {
      def width = resume(CANVAS_WIDTH)
      def height = resume(CANVAS_HEIGHT)
    }
    
    requestIdleCallback(idleCallback)
  }

  def pressedHandler(event: Event): Unit = 
    keysPressed.update(event.getKey(), true)
  def releasedHandler(event: Event): Unit = 
    keysPressed.update(event.getKey(), false)

  def mouseMoveHandler(event: Event): Unit = {
    val x = event.getClientX()
    val y = event.getClientY()
    mousePos.set(Vec2d(x, y))
  }
  def mouseDownHandler(event: Event): Unit = {
    val leftButtonPressed = event.getButton() == 0
    if (leftButtonPressed) {
      val player = game.get.player
      if (player.isAlive()) {
        val playerCenter = player.drawable.getCenter()
        val gunAngle = angleClockwise(mousePos.get - playerCenter)
        val bulletDrawable = player.gun.changeColor(Black())
        val bullet = Bullet(
          Rotate(Simple(bulletDrawable), gunAngle, Some(playerCenter)),
          Vec2d(1.0, 0.0).rotate(gunAngle)
        )
        game.map{g => g.addObject(bullet)}
      } else if (mousePos.get.isInside(RETRY_BUTTON.toHitbox())) {
        game.set(START_GAME)
      }
    }
  }

  addEventListener(KEY_DOWN, pressedHandler)
  addEventListener(KEY_UP, releasedHandler)
  addEventListener(MOUSE_MOVE, mouseMoveHandler)
  addEventListener(MOUSE_DOWN, mouseDownHandler)

  requestIdleCallback(idleCallback)
}