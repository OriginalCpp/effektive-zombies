module main

import src/ffi

val KEY_DOWN = "keydown"
val CANVAS_WIDTH = 1920
val CANVAS_HEIGHT = 1080

type Color {
  Green()
  Red()
}

def toString(color: Color): String = color match {
  case Green() => "green"
  case Red()   => "red"
}

type Drawable {
  Rect(x: Double, y: Double, width: Int, height: Int, color: Color)
  Circle(x: Double, y: Double, radius: Int, color: Color)
}

interface Canvas {
  def get(): Node
  def draw(object: Drawable): Unit
  def clear(): Unit
}

def canvas[T] { function: () => T / {Canvas} }: T = {
  try {
    function()
  } with Canvas {
    def get = resume(getElementById("canvas").getOrElse { createCanvas(CANVAS_WIDTH, CANVAS_HEIGHT) })
    def draw(object) = {
      canvas { 
        object match {
          case Rect(x, y, width, height, color) => 
            drawRect(do get(), x, y, width, height, color.toString())
          case _ => ()
        } 
      }
      resume(())
    }
    def clear = {
      canvas { clear(do get()) }
      resume(())
    }
  }
}

def move(object: Drawable, dx: Double, dy: Double): Drawable = object match {
  case Rect(x, y, w, h, c) => Rect(x + dx, y + dy, w, h, c)
  case Circle(x, y, r, c) => Circle(x + dx, y + dy, r, c)
}

type Event = String

def main(): Unit = {
  val PLAYER_WIDTH = 100
  val PLAYER_HEIGHT = 100
  val player = ref[Drawable](Rect(150.0, 100.0, PLAYER_WIDTH, PLAYER_HEIGHT, Green()))
  val now = ref[Int](getTime())

  def render(deadline: IdleDeadline): Unit = {
    with canvas;
    do clear()
    do draw(player.get)
    requestIdleCallback(render)
  }

  def calcDt(): Int = {
    val timeElapsed = getTime() - now.get()
    now.set(getTime())
    timeElapsed
  }

  def eventHandler(event: Event): Unit = event match {
    case "w" => {
      val dt: Int = calcDt()
      val dtToDouble: Double = dt.toDouble
      player.set(move(player.get, 0.0, -1.0 * dtToDouble / 10.0))
    }
    case "a" =>
      with canvas; 
      do draw(Rect(300.0, 100.0, 150, 100, Red())) 
    case  _  => ()
  }
  addEventListener(KEY_DOWN, eventHandler)
  requestIdleCallback(render)
}