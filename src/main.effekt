module main

import src/ffi

val KEY_DOWN = "keydown"
val KEY_UP = "keyup"
val CANVAS_WIDTH = 1920
val CANVAS_HEIGHT = 1080

type Color {
  Green()
  Red()
}

def toString(color: Color): String = color match {
  case Green() => "green"
  case Red()   => "red"
}

type Drawable {
  Rect(pos: Vec2d, width: Int, height: Int, color: Color)
  Circle(pos: Vec2d, radius: Int, color: Color)
}

record GameObject(hitbox: Drawable, movement: Vec2d)

interface Canvas {
  def get(): Node
  def draw(object: GameObject): Unit
  def clear(): Unit
}

def canvas[T] { function: () => T / {Canvas} }: T = {
  try {
    function()
  } with Canvas {
    def get = resume(getElementById("canvas").getOrElse { createCanvas(CANVAS_WIDTH, CANVAS_HEIGHT) })
    def draw(object) = {
      canvas { 
        object.hitbox match {
          case Rect(pos, width, height, color) => 
            drawRect(do get(), pos.x, pos.y, width, height, color.toString())
          case _ => ()
        } 
      }
      resume(())
    }
    def clear = {
      canvas { clear(do get()) }
      resume(())
    }
  }
}

def move(object: Ref[GameObject], dt: Int): Unit = {
  val newHitbox = move(object.get.hitbox, dt * object.get.movement.normalize())
  object.set(GameObject(newHitbox, Vec2d(0.0, 0.0)))
}

def move(drawable: Drawable, dVec: Vec2d): Drawable = drawable match {
  case Rect(pos, w, h, c) => Rect(pos + dVec, w, h, c)
  case Circle(pos, r, c) => Circle(pos + dVec, r, c)
}

type Event = String

def main(): Unit = {
  val PLAYER_WIDTH = 100
  val PLAYER_HEIGHT = 100
  val PLAYER_SPEED = 100
  val player = ref[GameObject](
    GameObject(Rect(Vec2d(150.0, 100.0), PLAYER_WIDTH, PLAYER_HEIGHT, Green()), Vec2d(0.0, 0.0))
  )
  val now = ref[Int](getTime())

  def calcDt(): Int = {
    val timeElapsed = getTime() - now.get()
    now.set(getTime())
    timeElapsed
  }

  def render(deadline: IdleDeadline): Unit = {
    val dt = calcDt()
    player.move(dt)
    with canvas;
    do clear()
    do draw(player.get)
    requestIdleCallback(render)
  }

  def eventHandler(event: Event): Unit = {
    val phb = player.get.hitbox
    val pm = player.get.movement
    event match {
      case "w" => player.set(GameObject(phb, Vec2d(pm.x, -1.0)))
      case "a" => player.set(GameObject(phb, Vec2d(-1.0, pm.y)))
      case "s" => player.set(GameObject(phb, Vec2d(pm.x, 1.0)))
      case "d" => player.set(GameObject(phb, Vec2d(1.0, pm.y)))
      case  _  => () 
    }
  }

  addEventListener(KEY_DOWN, eventHandler)
  requestIdleCallback(render)
}