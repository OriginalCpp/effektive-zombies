module gameTest

import test
import mutable/map
import src/game
import src/utils
import src/vec2d
import src/shapes/manipulated
import src/shapes/simple

def gameSuite() = suite("game") {
  val DUMMY_PLAYER = Player(
    Circle(NULL_VECTOR, 0.0, Green()),
    Rect(NULL_VECTOR, 0.0, 0.0, Black()), 0, 0.0
  )
  val DUMMY_TIMER = Timer(0)
  val DUMMY_TIMERS = GameTimer(DUMMY_TIMER, DUMMY_TIMER)
  val DUMMYGAME = GameState(DUMMY_PLAYER, [], DUMMY_TIMERS, 0)

  def pseudoHandler { f: () => Unit / {Input, random, Screen} }: Unit = {
    try { f() }
    with Screen {
      def width = resume(0.0)
      def height = resume(0.0)
    } with Input {
      def isPressed(key) = resume(false)
      def mousePos() = resume(NULL_VECTOR)
    } with random { resume(0.0) }
  }

  test("playerMovement") {
    val keyMap = emptyMap[String, Bool]()
    def assertV(expected: Vec2d) = {
      val calculated = try { wasdDirection() }
      with Input {
        def isPressed(key) = resume(keyMap.get(key).getOrElse { false })
        def mousePos() = resume(NULL_VECTOR)
      }
      val msg = "Map " ++ show(keyMap.keys()) ++ " " ++ show(keyMap.values) ++ ".wasdDirection() = "
                ++ show(calculated) ++ ", but expected " ++ show(expected) 
      assertTrue(calculated == expected, msg)
    }
    assertV(NULL_VECTOR)
    keyMap.update("w", true)
    assertV(Vec2d(0.0, -1.0))
    keyMap.update("s", true)
    assertV(NULL_VECTOR)
    keyMap.update("a", true)
    assertV(Vec2d(-1.0, 0.0))
    keyMap.update("w", false)
    assertV(Vec2d(-1.0 / sqrt(2.0), 1.0 / sqrt(2.0)))
    keyMap.update("s", false)
    assertV(Vec2d(-1.0, 0.0))
    keyMap.update("d", true)
    assertV(NULL_VECTOR)
  }

  test("timer") {
    var timer = Timer(10)
    val nonElapsing = [0, 1, 2, 3]
    val notElapsed = nonElapsing.map { dt => 
      try { 
        val (newTimer, _) = timer.timer(dt, ())
        timer = newTimer 
        true
      } with elapsed[Unit] { false }
    }

    assertTrue(notElapsed.all{ x => x })
    assertEqual(timer, Timer(4))

    val elapsing = [4, 5]
    val elapsed = elapsing.map { dt =>
      try {
        timer.timer(dt, ())
        false
      } with elapsed[Unit] { true }
    }

    assertTrue(elapsed.all{ x => x })
  }

  test("zombie shooting") {
    val SHOT_ZOMBIE_HITBOX = Simple(Rect(Vec2d(50.0, 50.0), 10.0, 10.0, Black()))
    val SHOT_ZOMBIE = Zombie(
      SHOT_ZOMBIE_HITBOX,
      Vec2d(1.0, 1.0)
    )
    val ALIVE_HITBOX = Simple(Rect(Vec2d(100.0, 100.0), 10.0, 10.0, Black()))
    val ALIVE = Zombie(
      ALIVE_HITBOX,
      Vec2d(1.0, 1.0)
    )
    val BULLET_HITBOX = Simple(Rect(Vec2d(40.0, 40.0), 20.0, 20.0, Black()))
    val BULLET = Bullet(
      BULLET_HITBOX,
      Vec2d(1.0, 1.0)
    )

    assertTrue(
      SHOT_ZOMBIE_HITBOX.collides(BULLET_HITBOX),
      "Bullet should collide with overlapping zombie"
    )

    assertFalse(
      ALIVE_HITBOX.collides(BULLET_HITBOX),
      "Bullet should not collide with non-overlapping zombie"
    )
    
    val remaining = shooting([SHOT_ZOMBIE, ALIVE, BULLET])

    assertTrue(
      remaining.contains(ALIVE){(a, b) => a.equals(b)},
      "Zombie that was not shot is dead"
    )
    assertFalse(
      remaining.contains(SHOT_ZOMBIE){(a, b) => a.equals(b)},
      "Shot zombie is not dead"
    )
    assertFalse(
      remaining.contains(BULLET){(a, b) => a.equals(b)},
      "Bullet that hit zombie is still in the game"
    )
  }
}