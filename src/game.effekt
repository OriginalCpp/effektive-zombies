module game

import src/constants
import src/ffi
import src/text
import src/utils
import src/vec2d
import src/shapes/manipulated
import src/shapes/simple

interface Canvas {
  def draw(drawable: ManipulatedDrawable): Unit
  def write(text: Text): Unit
  def clear(): Unit
}

interface Input {
  def isPressed(key: String): Bool
  def mousePos(): Vec2d
}

interface Screen {
  def width(): Double
  def height(): Double
}

def visible(d: ManipulatedDrawable): Bool / Screen = 
  collides(d, Simple(Rect(NULL_VECTOR, do width(), do height(), Black())))

record Timer(left: Int)

effect elapsed[R](): (Timer, R)

def timer[R](t: Timer, elapsed: Int, default: R): (Timer, R) / elapsed[R] = {
  val remaining = t.left - elapsed
  val hasElapsed = remaining <= 0
  if (hasElapsed) do elapsed[R]()
  else (Timer(remaining), default)
}

type GameObject {
  Bullet(drawable: ManipulatedDrawable, movementVector: Vec2d)
  Zombie(drawable: ManipulatedDrawable, movementVector: Vec2d)
}

def getCenter(object: GameObject): Vec2d = object match {
  case Bullet(hitbox, _) => hitbox.getCenter()
  case Zombie(hitbox, _) => hitbox.getCenter()
}

def getHitbox(object: GameObject): ManipulatedDrawable = object match {
  case Bullet(hitbox, _) => hitbox
  case Zombie(hitbox, _) => hitbox
}

record Player(drawable: SimpleDrawable, gun: SimpleDrawable, health: Int, speed: Double)

def isAlive(player: Player): Bool = player.health > 0

def changeHealth(player: Player, by: Int): Player = 
  Player(player.drawable, player.gun, player.health + by, player.speed)

def keepInsideScreen(player: Player): Player / Screen = {
  val screenW = do width()
  val screenH = do height()
  val playerCenter = player.drawable.getCenter()
  val centerInside = Vec2d(
    playerCenter.x.clamp(0.0, screenW),
    playerCenter.y.clamp(0.0, screenH)
  )
  val adjustment = centerInside - playerCenter
  Player(
    player.drawable.move(adjustment), 
    player.gun.move(adjustment), 
    player.health,
    player.speed
  )
}

record GameTimer(zombieTimer: Timer, waveTimer: Timer)

record Score(score: Int, combo: Int, maxCombo: Int)

def update(score: Score, comboBreak: Bool, hits: Int): Score = {
  var combo = if (comboBreak) 0 else score.combo
  var hitsM = hits
  var addition = 0
  while(hitsM > 0) {
    addition = inc(addition) + combo
    combo = inc(combo)
    hitsM = hitsM - 1
  }
  Score(score.score + addition, combo, max(combo, score.maxCombo))
}

def show(score: Score): String = 
  "Score: " ++ show(score.score) ++ "\nMax. Combo: " ++ show(score.maxCombo)

record GameState(
  player: Player,
  objects: List[GameObject],
  timers: GameTimer,
  wave: Int,
  score: Score
)

def addObject(game: GameState, gameObject: GameObject): GameState = 
  GameState(
    game.player, Cons(gameObject, game.objects), 
    game.timers, game.wave, game.score
  )

type Side {
  Top()
  Right()
  Bottom()
  Left()
}

val SIDES = [Top(), Right(), Bottom(), Left()]

def spawnZombie(game: GameState): GameObject / { Screen, random } = {
  val w = do width()
  val h = do height()
  val totalScreenEdge = 2.0 * w + 2.0 * h
  val sideProbs = [w, h, w, h].map {side => side / totalScreenEdge}
  val spawnSide = SIDES.choose(sideProbs).getOrElse{Right()}
  val r = do random()
  val zombiePos = spawnSide match {
    case Right() => Vec2d(w, r * h)
    case Bottom() => Vec2d(r * w, h)
    case Left() => Vec2d(0.0, r * h)
    case Top() => Vec2d(r * w, 0.0)
  }
  val player = game.player
  val zombieSize = h / 15.0
  val zombie = Zombie(Simple(Circle(zombiePos, zombieSize, Black())), Vec2d(0.3, 0.0))
  zombie
}

def move(gameObject: GameObject, dt: Int): GameObject = gameObject match {
  case Bullet(hitbox, movementVector) => 
    Bullet(hitbox.move(movementVector * dt), movementVector)
  case Zombie(hitbox, movementVector) =>
    Zombie(hitbox.move(movementVector * dt), movementVector)
}

def wasdDirection(): Vec2d / Input = {
  val wPressed = do isPressed("w") || do isPressed("W")
  val aPressed = do isPressed("a") || do isPressed("A")
  val sPressed = do isPressed("s") || do isPressed("S")
  val dPressed = do isPressed("d") || do isPressed("D")
  val xDirection = aPressed.toDouble.neg + dPressed.toDouble
  val yDirection = wPressed.toDouble.neg + sPressed.toDouble
  Vec2d(xDirection, yDirection).normalize()
}

def move(player: Player, dt: Int): Player / Input = {
  val movement = 
    player.speed * dt.toDouble * wasdDirection()
  Player(
    player.drawable.move(movement), 
    player.gun.move(movement),
    player.health,
    player.speed
  )
}

def shooting(objects: List[GameObject]): (List[GameObject], Int, Bool) / Screen = {
  val (inRange, outOfRange) = objects.partition {
    case Bullet(hitbox, _) => hitbox.visible()
    case _ => true
  }

  val (bullets, zombies) = inRange.partition {
    case Bullet(_, _) => true
    case Zombie(_, _) => false
  }

  val (bulletsThatHit, remainingBullets) = bullets.partition {
    case Bullet(sHitbox, _) =>
      zombies.any {
        case Zombie(zHitbox, _) => sHitbox.collides(zHitbox)
        case _ => false
      }
    case _ => false
  }

  val (dead, alive) = zombies.partition {
    case Zombie(zHitbox, _) =>
      bulletsThatHit.any {
        case Bullet(sHitbox, _) => zHitbox.collides(sHitbox)
        case _ => false
      }
    case _              => false
  }

  (alive.append(remainingBullets), dead.size, outOfRange.nonEmpty)
}

def update(game: GameState, dt: Int): GameState / { Input, random, Screen } = {
  val player = game.player
  val movedPlayer = player.move(dt)
  val objects = game.objects
  val timers = game.timers
  val wave = game.wave
  val score = game.score

  val (remaining, deadZombies, bulletMissed) = shooting(objects)

  val (damagingZombies, remainingObjects) = remaining.partition {
    case Zombie(hitbox, _) => hitbox.collides(Simple(player.drawable))
    case _ => false
  }

  val playerHealthLoss = damagingZombies.size

  val movedObjects = remainingObjects.map {
    case Zombie(h, m) =>
      val zombieCenter = h.getCenter()
      val zombiePlayerVec = player.drawable.getCenter() - zombieCenter
      val missingAngle = angleClockwise(zombiePlayerVec) - angleClockwise(m)
      val newHitbox = Rotate(h, missingAngle, None()).collapseRotations()
      Zombie(newHitbox, m.rotate(missingAngle)).move(dt)
    case o => o.move(dt)
  }

  val (updatedWaveTimer, updatedWave) = 
    try { timers.waveTimer.timer[Int](deadZombies, wave) }
    with elapsed[Int] {
      val newWave = inc(wave)
      (Timer(START_WAVE_TIMER * newWave), newWave)
    }

  val (updatedZombieTimer, spawnedZombie) = 
    try { timers.zombieTimer.timer(dt, Nil[GameObject]) }
    with elapsed[List[GameObject]] { 
      (Timer(ZOMBIE_SPAWN_INTERVAL / updatedWave), [spawnZombie(game)])
    }

  val updatedPlayer = movedPlayer.changeHealth(playerHealthLoss.neg)
                      .keepInsideScreen()
  val updatedObjects = spawnedZombie.append(movedObjects)
  val updatedTimers = GameTimer(updatedZombieTimer, updatedWaveTimer)
  val updatedScore = score.update(playerHealthLoss > 0 || bulletMissed, deadZombies)
  GameState(updatedPlayer, updatedObjects, updatedTimers, updatedWave, updatedScore)
}

def render(game: GameState): Unit / { Canvas, Input } = {
  val gunAngle = 
    angleClockwise(do mousePos() - game.player.drawable.getCenter())
  do clear()
  do draw(Rotate(
    Compose(Simple(game.player.drawable),
    Simple(game.player.gun)), 
    gunAngle, None()
  ))
  game.objects.foreach { o => do draw(o.getHitbox()) }
}

def renderDeathScreen(): Unit / { Canvas, Screen } = {
  val w = do width()
  val h = do height()
  val center = Vec2d(w / 2.0, h / 2.0)

  val background = Simple(Rect(NULL_VECTOR, w, h, Black()))

  val YOU_DIED = Text(
    "You Died",
    center - fromInt(0, 100),
    48,
    Serif(),
    Center(),
    Bottom(),
    Red()
  )

  do draw(background)
  do write(YOU_DIED)
}